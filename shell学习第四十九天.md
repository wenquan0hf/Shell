## shell 学习四十九天----进程建立

**进程**

前言：进程指的是执行中程序的一个实例。新进程由 `fork()` 与 `execve()` 等系统调用所起始，然后执行，知道他们下达 `exit()` 系统调用为止。

linux 系统都支持多进程。虽然计算机看起来像是一次做了很多事，但除非是他拥有多个 CPU，否则一次做了好多事只是个错觉。事实上，每个进程仅容许在一个极短的期间执行，我们称为时间片段，之后进程会先暂时搁置，让其他等待中进程执行。时间片段极短，通常只有几微妙，所以人们很少感觉到进程将控制权交回内核，再交给另一个进程的这种文本切换。进程本身不会管理文本切换这件事，也没有必要在程序里撰写撤回控制权予 OS 的处理。
 
操作系统内核里，称为调度器的部分负责管理进程的执行。当出现多 CPU 时，调度器会试着使用所有 CPU 处理工作负载。用户除了觉得响应速度的改善之外，多半不会察觉有何不同。
 
进程会被指定优先级，这么一来，有时间考虑的进程便能比不重要的进程先执行。`nice` 与 `renice` 命令即用于调整进程的优先级。  

在任何瞬间，等待执行之进程的平均数，被称为平均负载，最简单的 uptime 命令便能显示：

```
$uptime
20：30：35 up 45 min， 2 users， load average：0.05，0.11，0.05```

分析：显示开机至今的时间，用户数，以及平均负载。
 
由于平均负载会一直变化，`uptime` 会回报三个平均时间估算值，分别为最后一分钟，五分钟，以及十分钟的估算值。当平均负载持续的超出可用 CPU 的承载时，表示系统工作已超出它所能负荷的了，此时响应可能会陷入停滞不前的状态。
  
**进程建立**

很多程序都有 shell 启动：每个命令行里的第一个单词是识别要执行的程序。一个命令 shell 所起始每个进程，都会以下列保证事项启动：

1. 进程具有一个内核本文：在内核里的数据结构，会记录与进程相关的信息，让内核便于管理与控制进程的执行。
2. 进程拥有一个私有的，被保护的虚拟地址空间，它可能就像机器可定址空间那么大. 不过，其他资源的限制，像是实例内存与外部存储设备上的 swap 空间所组合的大小，其他执行中工作的大小，或是系统调校参数的本地端设置，都会加诸进程执行上的限制。
3. 三个文件描述符 (标准输入，标准输出，标准错误输出) 都已开启，且立即可用。
4. 起始于交谈模式 shell 的进程，会拥有一个控制终端机，其扮演三个标准文件数据流而定默认来源处与目的地。控制终端机是让用户可将信号传送给进程。
5. 命令行参数里的通配字符会被展开
6. 内存的一个环境变量区域会存在，包含具有键与值指定的字符串，可通过程序库调用取得。
 
这些保证没有任何差别待遇； 所有执行于相同优先级层级的进程都一视同仁，且进程可以由任何程序写成。私有地址空间可确保进程不受其他程序不瘦其他进城或内核干扰。未提供这样保障的操作系统很容易出错。这三个已开启的文件，对大部分的程序来说已经足够，可以使用他们而无需烦恼文件开启与关闭的操作，也不需要知道任何文件名语法或文件系统。由 shell 展开的通配符字符串会免除程序的很多负担，也提供了统一性的命令行处理。环境空间使出了命令与输入文件之外，可提供信息给进程的另一种方式。