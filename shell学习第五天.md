## shell 学习第五天----基本的 I/O 重定向

### 基本的 I/O 重定向

在了解重定向之前，需要先了解一下标准的输入输出，总的来说，所有的数据都有来源，也都应该都重点，默认的标准输入输出就是终端。  

例如:  

我们只是输入 cat 命令，并不指定任何参数，接着我们输入 hello world，就是打印 helloworld 到终端。  
所谓的 I/O 重定向就是通过与终端交互，或是在 shell 脚本里设置，重新安排从哪里输入或者输出到哪里。
 
### 重定向与管道

使用 < 改变标准输入

program<file 可将 program 的标准输入修改为 file

tr

使用 > 改变标准输出

`program>file` 可将 program 的标准输出修改为 file

> 重定向符号在墓地文件不存在的时候会新建一个，如果目的文件存在，目的文件的内容会被覆盖，原本的数据会丢失。
 
以 >> 附加到文件

`program>>file` 可以将 program 的标准输出追加到 file 的结尾处。

如同 >，open or create 文件，但是 >> 会追加到文件的结尾而不是覆盖原文件内容。

以 | 符号建立管道

program1 | program2 可将 program 的标准输出修改为 program2 的标准输入。这样做的好处是执行速度较快，不会产生临时文件。一般情况下，越复杂越强大的管道往往是高效的。

例如:`tr -d ‘\r’ dos-file.txt | sort >Linux-file.txt`
这条管道会先删除输入文件内的回车符号，在完成数据的排序之后，将结果输出到目的文件。
 
r 是 translate 的简写，通过这个单词，你大概也能猜到它是干什么的了吧！没错，它可以用一个字符串来替换另一个字符串，或者可以完全除去一些字符。您也可以用它来除去重复字符。tr 用来从标准输入中通过替换或删除操作进行字符转换。tr 主要用于删除文件中控制字符或进行字符转换。

`tr [options] cource-char-file replace-char-list`

例如:

1. 去除 oops.txt 里面的重复的小写字符 `tr -s "[a-z]"<oops.txt>result.txt`
2. 删除空行 `tr -s "[\012]" < plan.txt 或 tr -s ["\n"] < plan.txt`
3. 有时需要删除文件中的 `^M`，并代之以换行 `tr -s "[\015]" "[\n]" < file 或 tr -s "[\r]" "[\n]" < file`
4. 大写到小写 `cat a.txt |tr "[a-z]" "[A-Z]" >b.txt`
 
 
### 各个选项的意义的:

- -c: 取 `source-char-list` 的反义，tr 要转换的字符编程位列在 `source-char-list` 中的字符，通常与选项 -d.-s 配合使用。
- -d: 删除标准输入里的字符，不是转换他们
- -s: 产出重复的字符，如果标准输入里出现了重复多次的 `source-char-list` 里所列的字符，将其浓缩成一个。
 
### tr 的行为模式

如同过滤器一般，自标准输入读取字符，再将结果写到标准输出，任何输入字符只要出现在 `source-char-list` 中，就会置换成 `replace-char-list` 里相应的字符。
 
在使用 linux 的工具程序是，不妨将数据想想成谁管理的谁，未经处理的水，流向净水厂，经过各种过滤器的处理，最后变成适合人类饮用的水。可以把 < 和 > 想象成数据的漏斗---- 数据会从大的一头进入，从小的一头出来。

在构造管道的时候，应该试着让每个阶段的数据量变少，也就是说，吧会让数据变少的命令放在前边，为后面的命令提供搞笑的执行效率。例如，shiyongsort 排序之前，先用 grep 找出相关的行，这样可以让 sort 少做些事。