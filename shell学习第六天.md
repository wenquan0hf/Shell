## shell 学习第六天----小结

shell 中的两个特殊文件 “/dev/null” 和 “/dev/tty”  

1. `/dev/null`
当被用作重定向输出时，程序的输出被直接丢弃。该文件用在哪些不关心程序输出的地方。
当被用作重定向输入时，输入则是文件结束。
 
2. `/dev/tty`
当被用作重定向时，表示重定向到终端。
 
### 基本命令查找

shell 会沿着 `$PATH` 来寻找命令。`$PATH` 是一个以冒号分割的目录列表，你可以在列表所指定的目录下找到所要执行的命令。命令可能是 shell 脚本，也可能是编译后的可执行文件，从用户角度来看，二者并无不同。默认路径至少包含 `/bin` 和 `/usr/bin`，或许还包含其他的。名称为 bin 的目录用来保存可执行文件。
 
如果要编写自己的脚本，最好准备一个自己的 bin 目录来存放他们，并且让 shell 能够自动找到他们。

```
$cd                                     
$mkdir bin
$mv nusers bin
$PATH+$PATH:$HOME/bin         // 将个人的 bin 目录附加到 PATH(暂时生效，系统重启后失效)
nusers 
```    
 
要想永久生效，在 `/etc/profile` 文件中把你的 bin 目录加入到 `$PATH`，而每次登陆时 Shell 都将读取.profile 文件。

`PATH=$PATH:$HOME/bin`

$PATH 里的空项目表示当前项目。空项目位于路径中间时，可以用两个连续的冒号来表示，如果将冒号直接置于最前端或尾端，分别表示查找的时候最先查找或最后查找当前目录。

`$PATH=:/bin:/usr/bin            先找当前目录`  
`$PATH=/bin::/usr/bin            当前目录居中`   
`$PATH=/bin:/usr/bin:            最后找当前目录`  
不应该在查找路径中放进当前项目。
 
访问 shell 脚本的参数

定义参数关键字 $: 例如 `echo frist argumentsis $1`，大于等于 10 的参数需要用{}包起来，`echo tenth argumentsis ${10}`
 
例如我们想查找名字为 syx 用户是否登陆

`who | grep syx`  
`syx      pts/1        2015-06-09 11:00 (192.168.199.114)`

知道了如何寻找特定的用户后，我们可以经命令放在脚本里，这段脚本的第一个参数就是我们要找的用户名称

`vi findname              建立新文件`  
`#!/bin/sh`  
`#查看指定用户是否登录`      
`who | grep $1`
 
`./findname syx`
`syx      pts/1        2015-06-09 11:00 (192.168.199.114)`

但是这是在理想情况下，如果用户不按套路出牌，即不指定参数，则会报错。

### 小结

编译性语言和脚本语言本身并无优劣之分，只有适合不适合；当对性能要求不高，希望尽快开发出程序并以较高的方式工作是，脚本语言完全可以胜任。所有的 shell 脚本都应该以#!为第一行，这一机制可让你的脚本更有灵活性，你可以选择使用 shell 或其他的语言来编写脚本。
 
shell 是一个完整的程序设计语言，我们已经说明过基本的命令，选项，参数与变量，以及 `echo` 与 `printf` 的基本输出，也稍微说了一下基本的 I/O 重定向符:<，>，>> 以及 |。shell 会在 $PATH 变量所列举的各个目录中寻找命令。`$PATH` 常会包含个人的 bin 目录 (永爱存储用户个人的程序与脚本)，可以在 `/etc/profile` 文件中将目录列入到 `PATH` 里。